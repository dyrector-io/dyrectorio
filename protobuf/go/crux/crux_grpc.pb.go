// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.18.1
// source: protobuf/proto/crux.proto

package crux

import (
	context "context"
	common "github.com/dyrector-io/dyrectorio/protobuf/go/common"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CruxProductClient is the client API for CruxProduct service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxProductClient interface {
	// CRUD
	GetProducts(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*ProductListResponse, error)
	CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	UpdateProduct(ctx context.Context, in *UpdateProductRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error)
	DeleteProduct(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetProductDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*ProductDetailsReponse, error)
}

type cruxProductClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxProductClient(cc grpc.ClientConnInterface) CruxProductClient {
	return &cruxProductClient{cc}
}

func (c *cruxProductClient) GetProducts(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*ProductListResponse, error) {
	out := new(ProductListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProduct/GetProducts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductClient) CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProduct/CreateProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductClient) UpdateProduct(ctx context.Context, in *UpdateProductRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error) {
	out := new(UpdateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProduct/UpdateProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductClient) DeleteProduct(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxProduct/DeleteProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductClient) GetProductDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*ProductDetailsReponse, error) {
	out := new(ProductDetailsReponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProduct/GetProductDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxProductServer is the server API for CruxProduct service.
// All implementations must embed UnimplementedCruxProductServer
// for forward compatibility
type CruxProductServer interface {
	// CRUD
	GetProducts(context.Context, *AccessRequest) (*ProductListResponse, error)
	CreateProduct(context.Context, *CreateProductRequest) (*CreateEntityResponse, error)
	UpdateProduct(context.Context, *UpdateProductRequest) (*UpdateEntityResponse, error)
	DeleteProduct(context.Context, *IdRequest) (*common.Empty, error)
	GetProductDetails(context.Context, *IdRequest) (*ProductDetailsReponse, error)
	mustEmbedUnimplementedCruxProductServer()
}

// UnimplementedCruxProductServer must be embedded to have forward compatible implementations.
type UnimplementedCruxProductServer struct {
}

func (UnimplementedCruxProductServer) GetProducts(context.Context, *AccessRequest) (*ProductListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProducts not implemented")
}
func (UnimplementedCruxProductServer) CreateProduct(context.Context, *CreateProductRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProduct not implemented")
}
func (UnimplementedCruxProductServer) UpdateProduct(context.Context, *UpdateProductRequest) (*UpdateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProduct not implemented")
}
func (UnimplementedCruxProductServer) DeleteProduct(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProduct not implemented")
}
func (UnimplementedCruxProductServer) GetProductDetails(context.Context, *IdRequest) (*ProductDetailsReponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductDetails not implemented")
}
func (UnimplementedCruxProductServer) mustEmbedUnimplementedCruxProductServer() {}

// UnsafeCruxProductServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxProductServer will
// result in compilation errors.
type UnsafeCruxProductServer interface {
	mustEmbedUnimplementedCruxProductServer()
}

func RegisterCruxProductServer(s grpc.ServiceRegistrar, srv CruxProductServer) {
	s.RegisterService(&CruxProduct_ServiceDesc, srv)
}

func _CruxProduct_GetProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductServer).GetProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProduct/GetProducts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductServer).GetProducts(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProduct_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProduct/CreateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductServer).CreateProduct(ctx, req.(*CreateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProduct_UpdateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductServer).UpdateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProduct/UpdateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductServer).UpdateProduct(ctx, req.(*UpdateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProduct_DeleteProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductServer).DeleteProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProduct/DeleteProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductServer).DeleteProduct(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProduct_GetProductDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductServer).GetProductDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProduct/GetProductDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductServer).GetProductDetails(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxProduct_ServiceDesc is the grpc.ServiceDesc for CruxProduct service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxProduct_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxProduct",
	HandlerType: (*CruxProductServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProducts",
			Handler:    _CruxProduct_GetProducts_Handler,
		},
		{
			MethodName: "CreateProduct",
			Handler:    _CruxProduct_CreateProduct_Handler,
		},
		{
			MethodName: "UpdateProduct",
			Handler:    _CruxProduct_UpdateProduct_Handler,
		},
		{
			MethodName: "DeleteProduct",
			Handler:    _CruxProduct_DeleteProduct_Handler,
		},
		{
			MethodName: "GetProductDetails",
			Handler:    _CruxProduct_GetProductDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxRegistryClient is the client API for CruxRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxRegistryClient interface {
	// CRUD
	GetRegistries(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*RegistryListResponse, error)
	CreateRegistry(ctx context.Context, in *CreateRegistryRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	UpdateRegistry(ctx context.Context, in *UpdateRegistryRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error)
	DeleteRegistry(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetRegistryDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*RegistryDetailsResponse, error)
}

type cruxRegistryClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxRegistryClient(cc grpc.ClientConnInterface) CruxRegistryClient {
	return &cruxRegistryClient{cc}
}

func (c *cruxRegistryClient) GetRegistries(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*RegistryListResponse, error) {
	out := new(RegistryListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxRegistry/GetRegistries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxRegistryClient) CreateRegistry(ctx context.Context, in *CreateRegistryRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxRegistry/CreateRegistry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxRegistryClient) UpdateRegistry(ctx context.Context, in *UpdateRegistryRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error) {
	out := new(UpdateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxRegistry/UpdateRegistry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxRegistryClient) DeleteRegistry(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxRegistry/DeleteRegistry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxRegistryClient) GetRegistryDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*RegistryDetailsResponse, error) {
	out := new(RegistryDetailsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxRegistry/GetRegistryDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxRegistryServer is the server API for CruxRegistry service.
// All implementations must embed UnimplementedCruxRegistryServer
// for forward compatibility
type CruxRegistryServer interface {
	// CRUD
	GetRegistries(context.Context, *AccessRequest) (*RegistryListResponse, error)
	CreateRegistry(context.Context, *CreateRegistryRequest) (*CreateEntityResponse, error)
	UpdateRegistry(context.Context, *UpdateRegistryRequest) (*UpdateEntityResponse, error)
	DeleteRegistry(context.Context, *IdRequest) (*common.Empty, error)
	GetRegistryDetails(context.Context, *IdRequest) (*RegistryDetailsResponse, error)
	mustEmbedUnimplementedCruxRegistryServer()
}

// UnimplementedCruxRegistryServer must be embedded to have forward compatible implementations.
type UnimplementedCruxRegistryServer struct {
}

func (UnimplementedCruxRegistryServer) GetRegistries(context.Context, *AccessRequest) (*RegistryListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegistries not implemented")
}
func (UnimplementedCruxRegistryServer) CreateRegistry(context.Context, *CreateRegistryRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRegistry not implemented")
}
func (UnimplementedCruxRegistryServer) UpdateRegistry(context.Context, *UpdateRegistryRequest) (*UpdateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRegistry not implemented")
}
func (UnimplementedCruxRegistryServer) DeleteRegistry(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRegistry not implemented")
}
func (UnimplementedCruxRegistryServer) GetRegistryDetails(context.Context, *IdRequest) (*RegistryDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegistryDetails not implemented")
}
func (UnimplementedCruxRegistryServer) mustEmbedUnimplementedCruxRegistryServer() {}

// UnsafeCruxRegistryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxRegistryServer will
// result in compilation errors.
type UnsafeCruxRegistryServer interface {
	mustEmbedUnimplementedCruxRegistryServer()
}

func RegisterCruxRegistryServer(s grpc.ServiceRegistrar, srv CruxRegistryServer) {
	s.RegisterService(&CruxRegistry_ServiceDesc, srv)
}

func _CruxRegistry_GetRegistries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxRegistryServer).GetRegistries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxRegistry/GetRegistries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxRegistryServer).GetRegistries(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxRegistry_CreateRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRegistryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxRegistryServer).CreateRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxRegistry/CreateRegistry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxRegistryServer).CreateRegistry(ctx, req.(*CreateRegistryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxRegistry_UpdateRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegistryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxRegistryServer).UpdateRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxRegistry/UpdateRegistry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxRegistryServer).UpdateRegistry(ctx, req.(*UpdateRegistryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxRegistry_DeleteRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxRegistryServer).DeleteRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxRegistry/DeleteRegistry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxRegistryServer).DeleteRegistry(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxRegistry_GetRegistryDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxRegistryServer).GetRegistryDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxRegistry/GetRegistryDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxRegistryServer).GetRegistryDetails(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxRegistry_ServiceDesc is the grpc.ServiceDesc for CruxRegistry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxRegistry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxRegistry",
	HandlerType: (*CruxRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRegistries",
			Handler:    _CruxRegistry_GetRegistries_Handler,
		},
		{
			MethodName: "CreateRegistry",
			Handler:    _CruxRegistry_CreateRegistry_Handler,
		},
		{
			MethodName: "UpdateRegistry",
			Handler:    _CruxRegistry_UpdateRegistry_Handler,
		},
		{
			MethodName: "DeleteRegistry",
			Handler:    _CruxRegistry_DeleteRegistry_Handler,
		},
		{
			MethodName: "GetRegistryDetails",
			Handler:    _CruxRegistry_GetRegistryDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxNodeClient is the client API for CruxNode service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxNodeClient interface {
	// CRUD
	GetNodes(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*NodeListResponse, error)
	CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*common.Empty, error)
	DeleteNode(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetNodeDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*NodeDetailsResponse, error)
	GenerateScript(ctx context.Context, in *GenerateScriptRequest, opts ...grpc.CallOption) (*NodeInstallResponse, error)
	GetScript(ctx context.Context, in *ServiceIdRequest, opts ...grpc.CallOption) (*NodeScriptResponse, error)
	DiscardScript(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	RevokeToken(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	UpdateNodeAgent(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	SubscribeNodeEventChannel(ctx context.Context, in *ServiceIdRequest, opts ...grpc.CallOption) (CruxNode_SubscribeNodeEventChannelClient, error)
	WatchContainerState(ctx context.Context, in *WatchContainerStateRequest, opts ...grpc.CallOption) (CruxNode_WatchContainerStateClient, error)
}

type cruxNodeClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxNodeClient(cc grpc.ClientConnInterface) CruxNodeClient {
	return &cruxNodeClient{cc}
}

func (c *cruxNodeClient) GetNodes(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*NodeListResponse, error) {
	out := new(NodeListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/GetNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) CreateNode(ctx context.Context, in *CreateNodeRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/CreateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) UpdateNode(ctx context.Context, in *UpdateNodeRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/UpdateNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) DeleteNode(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/DeleteNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) GetNodeDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*NodeDetailsResponse, error) {
	out := new(NodeDetailsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/GetNodeDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) GenerateScript(ctx context.Context, in *GenerateScriptRequest, opts ...grpc.CallOption) (*NodeInstallResponse, error) {
	out := new(NodeInstallResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/GenerateScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) GetScript(ctx context.Context, in *ServiceIdRequest, opts ...grpc.CallOption) (*NodeScriptResponse, error) {
	out := new(NodeScriptResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/GetScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) DiscardScript(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/DiscardScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) RevokeToken(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/RevokeToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) UpdateNodeAgent(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxNode/UpdateNodeAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNodeClient) SubscribeNodeEventChannel(ctx context.Context, in *ServiceIdRequest, opts ...grpc.CallOption) (CruxNode_SubscribeNodeEventChannelClient, error) {
	stream, err := c.cc.NewStream(ctx, &CruxNode_ServiceDesc.Streams[0], "/crux.CruxNode/SubscribeNodeEventChannel", opts...)
	if err != nil {
		return nil, err
	}
	x := &cruxNodeSubscribeNodeEventChannelClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CruxNode_SubscribeNodeEventChannelClient interface {
	Recv() (*NodeEventMessage, error)
	grpc.ClientStream
}

type cruxNodeSubscribeNodeEventChannelClient struct {
	grpc.ClientStream
}

func (x *cruxNodeSubscribeNodeEventChannelClient) Recv() (*NodeEventMessage, error) {
	m := new(NodeEventMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cruxNodeClient) WatchContainerState(ctx context.Context, in *WatchContainerStateRequest, opts ...grpc.CallOption) (CruxNode_WatchContainerStateClient, error) {
	stream, err := c.cc.NewStream(ctx, &CruxNode_ServiceDesc.Streams[1], "/crux.CruxNode/WatchContainerState", opts...)
	if err != nil {
		return nil, err
	}
	x := &cruxNodeWatchContainerStateClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CruxNode_WatchContainerStateClient interface {
	Recv() (*common.ContainerStateListMessage, error)
	grpc.ClientStream
}

type cruxNodeWatchContainerStateClient struct {
	grpc.ClientStream
}

func (x *cruxNodeWatchContainerStateClient) Recv() (*common.ContainerStateListMessage, error) {
	m := new(common.ContainerStateListMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CruxNodeServer is the server API for CruxNode service.
// All implementations must embed UnimplementedCruxNodeServer
// for forward compatibility
type CruxNodeServer interface {
	// CRUD
	GetNodes(context.Context, *AccessRequest) (*NodeListResponse, error)
	CreateNode(context.Context, *CreateNodeRequest) (*CreateEntityResponse, error)
	UpdateNode(context.Context, *UpdateNodeRequest) (*common.Empty, error)
	DeleteNode(context.Context, *IdRequest) (*common.Empty, error)
	GetNodeDetails(context.Context, *IdRequest) (*NodeDetailsResponse, error)
	GenerateScript(context.Context, *GenerateScriptRequest) (*NodeInstallResponse, error)
	GetScript(context.Context, *ServiceIdRequest) (*NodeScriptResponse, error)
	DiscardScript(context.Context, *IdRequest) (*common.Empty, error)
	RevokeToken(context.Context, *IdRequest) (*common.Empty, error)
	UpdateNodeAgent(context.Context, *IdRequest) (*common.Empty, error)
	SubscribeNodeEventChannel(*ServiceIdRequest, CruxNode_SubscribeNodeEventChannelServer) error
	WatchContainerState(*WatchContainerStateRequest, CruxNode_WatchContainerStateServer) error
	mustEmbedUnimplementedCruxNodeServer()
}

// UnimplementedCruxNodeServer must be embedded to have forward compatible implementations.
type UnimplementedCruxNodeServer struct {
}

func (UnimplementedCruxNodeServer) GetNodes(context.Context, *AccessRequest) (*NodeListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodes not implemented")
}
func (UnimplementedCruxNodeServer) CreateNode(context.Context, *CreateNodeRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNode not implemented")
}
func (UnimplementedCruxNodeServer) UpdateNode(context.Context, *UpdateNodeRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}
func (UnimplementedCruxNodeServer) DeleteNode(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (UnimplementedCruxNodeServer) GetNodeDetails(context.Context, *IdRequest) (*NodeDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeDetails not implemented")
}
func (UnimplementedCruxNodeServer) GenerateScript(context.Context, *GenerateScriptRequest) (*NodeInstallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateScript not implemented")
}
func (UnimplementedCruxNodeServer) GetScript(context.Context, *ServiceIdRequest) (*NodeScriptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScript not implemented")
}
func (UnimplementedCruxNodeServer) DiscardScript(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiscardScript not implemented")
}
func (UnimplementedCruxNodeServer) RevokeToken(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeToken not implemented")
}
func (UnimplementedCruxNodeServer) UpdateNodeAgent(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNodeAgent not implemented")
}
func (UnimplementedCruxNodeServer) SubscribeNodeEventChannel(*ServiceIdRequest, CruxNode_SubscribeNodeEventChannelServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeNodeEventChannel not implemented")
}
func (UnimplementedCruxNodeServer) WatchContainerState(*WatchContainerStateRequest, CruxNode_WatchContainerStateServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchContainerState not implemented")
}
func (UnimplementedCruxNodeServer) mustEmbedUnimplementedCruxNodeServer() {}

// UnsafeCruxNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxNodeServer will
// result in compilation errors.
type UnsafeCruxNodeServer interface {
	mustEmbedUnimplementedCruxNodeServer()
}

func RegisterCruxNodeServer(s grpc.ServiceRegistrar, srv CruxNodeServer) {
	s.RegisterService(&CruxNode_ServiceDesc, srv)
}

func _CruxNode_GetNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).GetNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/GetNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).GetNodes(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_CreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).CreateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/CreateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).CreateNode(ctx, req.(*CreateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_UpdateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).UpdateNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/UpdateNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).UpdateNode(ctx, req.(*UpdateNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).DeleteNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/DeleteNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).DeleteNode(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_GetNodeDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).GetNodeDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/GetNodeDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).GetNodeDetails(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_GenerateScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateScriptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).GenerateScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/GenerateScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).GenerateScript(ctx, req.(*GenerateScriptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_GetScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).GetScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/GetScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).GetScript(ctx, req.(*ServiceIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_DiscardScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).DiscardScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/DiscardScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).DiscardScript(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_RevokeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).RevokeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/RevokeToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).RevokeToken(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_UpdateNodeAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNodeServer).UpdateNodeAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNode/UpdateNodeAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNodeServer).UpdateNodeAgent(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNode_SubscribeNodeEventChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ServiceIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CruxNodeServer).SubscribeNodeEventChannel(m, &cruxNodeSubscribeNodeEventChannelServer{stream})
}

type CruxNode_SubscribeNodeEventChannelServer interface {
	Send(*NodeEventMessage) error
	grpc.ServerStream
}

type cruxNodeSubscribeNodeEventChannelServer struct {
	grpc.ServerStream
}

func (x *cruxNodeSubscribeNodeEventChannelServer) Send(m *NodeEventMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _CruxNode_WatchContainerState_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchContainerStateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CruxNodeServer).WatchContainerState(m, &cruxNodeWatchContainerStateServer{stream})
}

type CruxNode_WatchContainerStateServer interface {
	Send(*common.ContainerStateListMessage) error
	grpc.ServerStream
}

type cruxNodeWatchContainerStateServer struct {
	grpc.ServerStream
}

func (x *cruxNodeWatchContainerStateServer) Send(m *common.ContainerStateListMessage) error {
	return x.ServerStream.SendMsg(m)
}

// CruxNode_ServiceDesc is the grpc.ServiceDesc for CruxNode service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxNode_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxNode",
	HandlerType: (*CruxNodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNodes",
			Handler:    _CruxNode_GetNodes_Handler,
		},
		{
			MethodName: "CreateNode",
			Handler:    _CruxNode_CreateNode_Handler,
		},
		{
			MethodName: "UpdateNode",
			Handler:    _CruxNode_UpdateNode_Handler,
		},
		{
			MethodName: "DeleteNode",
			Handler:    _CruxNode_DeleteNode_Handler,
		},
		{
			MethodName: "GetNodeDetails",
			Handler:    _CruxNode_GetNodeDetails_Handler,
		},
		{
			MethodName: "GenerateScript",
			Handler:    _CruxNode_GenerateScript_Handler,
		},
		{
			MethodName: "GetScript",
			Handler:    _CruxNode_GetScript_Handler,
		},
		{
			MethodName: "DiscardScript",
			Handler:    _CruxNode_DiscardScript_Handler,
		},
		{
			MethodName: "RevokeToken",
			Handler:    _CruxNode_RevokeToken_Handler,
		},
		{
			MethodName: "UpdateNodeAgent",
			Handler:    _CruxNode_UpdateNodeAgent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeNodeEventChannel",
			Handler:       _CruxNode_SubscribeNodeEventChannel_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchContainerState",
			Handler:       _CruxNode_WatchContainerState_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxProductVersionClient is the client API for CruxProductVersion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxProductVersionClient interface {
	GetVersionsByProductId(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*VersionListResponse, error)
	CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	UpdateVersion(ctx context.Context, in *UpdateVersionRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error)
	DeleteVersion(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	SetDefaultVersion(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetVersionDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*VersionDetailsResponse, error)
	IncreaseVersion(ctx context.Context, in *IncreaseVersionRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
}

type cruxProductVersionClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxProductVersionClient(cc grpc.ClientConnInterface) CruxProductVersionClient {
	return &cruxProductVersionClient{cc}
}

func (c *cruxProductVersionClient) GetVersionsByProductId(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*VersionListResponse, error) {
	out := new(VersionListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProductVersion/GetVersionsByProductId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductVersionClient) CreateVersion(ctx context.Context, in *CreateVersionRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProductVersion/CreateVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductVersionClient) UpdateVersion(ctx context.Context, in *UpdateVersionRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error) {
	out := new(UpdateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProductVersion/UpdateVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductVersionClient) DeleteVersion(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxProductVersion/DeleteVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductVersionClient) SetDefaultVersion(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxProductVersion/SetDefaultVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductVersionClient) GetVersionDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*VersionDetailsResponse, error) {
	out := new(VersionDetailsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProductVersion/GetVersionDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxProductVersionClient) IncreaseVersion(ctx context.Context, in *IncreaseVersionRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxProductVersion/IncreaseVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxProductVersionServer is the server API for CruxProductVersion service.
// All implementations must embed UnimplementedCruxProductVersionServer
// for forward compatibility
type CruxProductVersionServer interface {
	GetVersionsByProductId(context.Context, *IdRequest) (*VersionListResponse, error)
	CreateVersion(context.Context, *CreateVersionRequest) (*CreateEntityResponse, error)
	UpdateVersion(context.Context, *UpdateVersionRequest) (*UpdateEntityResponse, error)
	DeleteVersion(context.Context, *IdRequest) (*common.Empty, error)
	SetDefaultVersion(context.Context, *IdRequest) (*common.Empty, error)
	GetVersionDetails(context.Context, *IdRequest) (*VersionDetailsResponse, error)
	IncreaseVersion(context.Context, *IncreaseVersionRequest) (*CreateEntityResponse, error)
	mustEmbedUnimplementedCruxProductVersionServer()
}

// UnimplementedCruxProductVersionServer must be embedded to have forward compatible implementations.
type UnimplementedCruxProductVersionServer struct {
}

func (UnimplementedCruxProductVersionServer) GetVersionsByProductId(context.Context, *IdRequest) (*VersionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionsByProductId not implemented")
}
func (UnimplementedCruxProductVersionServer) CreateVersion(context.Context, *CreateVersionRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVersion not implemented")
}
func (UnimplementedCruxProductVersionServer) UpdateVersion(context.Context, *UpdateVersionRequest) (*UpdateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVersion not implemented")
}
func (UnimplementedCruxProductVersionServer) DeleteVersion(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVersion not implemented")
}
func (UnimplementedCruxProductVersionServer) SetDefaultVersion(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultVersion not implemented")
}
func (UnimplementedCruxProductVersionServer) GetVersionDetails(context.Context, *IdRequest) (*VersionDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersionDetails not implemented")
}
func (UnimplementedCruxProductVersionServer) IncreaseVersion(context.Context, *IncreaseVersionRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncreaseVersion not implemented")
}
func (UnimplementedCruxProductVersionServer) mustEmbedUnimplementedCruxProductVersionServer() {}

// UnsafeCruxProductVersionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxProductVersionServer will
// result in compilation errors.
type UnsafeCruxProductVersionServer interface {
	mustEmbedUnimplementedCruxProductVersionServer()
}

func RegisterCruxProductVersionServer(s grpc.ServiceRegistrar, srv CruxProductVersionServer) {
	s.RegisterService(&CruxProductVersion_ServiceDesc, srv)
}

func _CruxProductVersion_GetVersionsByProductId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductVersionServer).GetVersionsByProductId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProductVersion/GetVersionsByProductId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductVersionServer).GetVersionsByProductId(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProductVersion_CreateVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductVersionServer).CreateVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProductVersion/CreateVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductVersionServer).CreateVersion(ctx, req.(*CreateVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProductVersion_UpdateVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductVersionServer).UpdateVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProductVersion/UpdateVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductVersionServer).UpdateVersion(ctx, req.(*UpdateVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProductVersion_DeleteVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductVersionServer).DeleteVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProductVersion/DeleteVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductVersionServer).DeleteVersion(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProductVersion_SetDefaultVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductVersionServer).SetDefaultVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProductVersion/SetDefaultVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductVersionServer).SetDefaultVersion(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProductVersion_GetVersionDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductVersionServer).GetVersionDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProductVersion/GetVersionDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductVersionServer).GetVersionDetails(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxProductVersion_IncreaseVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncreaseVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxProductVersionServer).IncreaseVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxProductVersion/IncreaseVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxProductVersionServer).IncreaseVersion(ctx, req.(*IncreaseVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxProductVersion_ServiceDesc is the grpc.ServiceDesc for CruxProductVersion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxProductVersion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxProductVersion",
	HandlerType: (*CruxProductVersionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVersionsByProductId",
			Handler:    _CruxProductVersion_GetVersionsByProductId_Handler,
		},
		{
			MethodName: "CreateVersion",
			Handler:    _CruxProductVersion_CreateVersion_Handler,
		},
		{
			MethodName: "UpdateVersion",
			Handler:    _CruxProductVersion_UpdateVersion_Handler,
		},
		{
			MethodName: "DeleteVersion",
			Handler:    _CruxProductVersion_DeleteVersion_Handler,
		},
		{
			MethodName: "SetDefaultVersion",
			Handler:    _CruxProductVersion_SetDefaultVersion_Handler,
		},
		{
			MethodName: "GetVersionDetails",
			Handler:    _CruxProductVersion_GetVersionDetails_Handler,
		},
		{
			MethodName: "IncreaseVersion",
			Handler:    _CruxProductVersion_IncreaseVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxImageClient is the client API for CruxImage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxImageClient interface {
	GetImagesByVersionId(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*ImageListResponse, error)
	AddImagesToVersion(ctx context.Context, in *AddImagesToVersionRequest, opts ...grpc.CallOption) (*ImageListResponse, error)
	OrderImages(ctx context.Context, in *OrderVersionImagesRequest, opts ...grpc.CallOption) (*common.Empty, error)
	PatchImage(ctx context.Context, in *PatchImageRequest, opts ...grpc.CallOption) (*common.Empty, error)
	DeleteImage(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetImageDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*ImageResponse, error)
}

type cruxImageClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxImageClient(cc grpc.ClientConnInterface) CruxImageClient {
	return &cruxImageClient{cc}
}

func (c *cruxImageClient) GetImagesByVersionId(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*ImageListResponse, error) {
	out := new(ImageListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxImage/GetImagesByVersionId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxImageClient) AddImagesToVersion(ctx context.Context, in *AddImagesToVersionRequest, opts ...grpc.CallOption) (*ImageListResponse, error) {
	out := new(ImageListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxImage/AddImagesToVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxImageClient) OrderImages(ctx context.Context, in *OrderVersionImagesRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxImage/OrderImages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxImageClient) PatchImage(ctx context.Context, in *PatchImageRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxImage/PatchImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxImageClient) DeleteImage(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxImage/DeleteImage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxImageClient) GetImageDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*ImageResponse, error) {
	out := new(ImageResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxImage/GetImageDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxImageServer is the server API for CruxImage service.
// All implementations must embed UnimplementedCruxImageServer
// for forward compatibility
type CruxImageServer interface {
	GetImagesByVersionId(context.Context, *IdRequest) (*ImageListResponse, error)
	AddImagesToVersion(context.Context, *AddImagesToVersionRequest) (*ImageListResponse, error)
	OrderImages(context.Context, *OrderVersionImagesRequest) (*common.Empty, error)
	PatchImage(context.Context, *PatchImageRequest) (*common.Empty, error)
	DeleteImage(context.Context, *IdRequest) (*common.Empty, error)
	GetImageDetails(context.Context, *IdRequest) (*ImageResponse, error)
	mustEmbedUnimplementedCruxImageServer()
}

// UnimplementedCruxImageServer must be embedded to have forward compatible implementations.
type UnimplementedCruxImageServer struct {
}

func (UnimplementedCruxImageServer) GetImagesByVersionId(context.Context, *IdRequest) (*ImageListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImagesByVersionId not implemented")
}
func (UnimplementedCruxImageServer) AddImagesToVersion(context.Context, *AddImagesToVersionRequest) (*ImageListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddImagesToVersion not implemented")
}
func (UnimplementedCruxImageServer) OrderImages(context.Context, *OrderVersionImagesRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderImages not implemented")
}
func (UnimplementedCruxImageServer) PatchImage(context.Context, *PatchImageRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchImage not implemented")
}
func (UnimplementedCruxImageServer) DeleteImage(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}
func (UnimplementedCruxImageServer) GetImageDetails(context.Context, *IdRequest) (*ImageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImageDetails not implemented")
}
func (UnimplementedCruxImageServer) mustEmbedUnimplementedCruxImageServer() {}

// UnsafeCruxImageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxImageServer will
// result in compilation errors.
type UnsafeCruxImageServer interface {
	mustEmbedUnimplementedCruxImageServer()
}

func RegisterCruxImageServer(s grpc.ServiceRegistrar, srv CruxImageServer) {
	s.RegisterService(&CruxImage_ServiceDesc, srv)
}

func _CruxImage_GetImagesByVersionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxImageServer).GetImagesByVersionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxImage/GetImagesByVersionId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxImageServer).GetImagesByVersionId(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxImage_AddImagesToVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddImagesToVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxImageServer).AddImagesToVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxImage/AddImagesToVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxImageServer).AddImagesToVersion(ctx, req.(*AddImagesToVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxImage_OrderImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderVersionImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxImageServer).OrderImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxImage/OrderImages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxImageServer).OrderImages(ctx, req.(*OrderVersionImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxImage_PatchImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxImageServer).PatchImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxImage/PatchImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxImageServer).PatchImage(ctx, req.(*PatchImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxImage_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxImageServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxImage/DeleteImage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxImageServer).DeleteImage(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxImage_GetImageDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxImageServer).GetImageDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxImage/GetImageDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxImageServer).GetImageDetails(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxImage_ServiceDesc is the grpc.ServiceDesc for CruxImage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxImage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxImage",
	HandlerType: (*CruxImageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetImagesByVersionId",
			Handler:    _CruxImage_GetImagesByVersionId_Handler,
		},
		{
			MethodName: "AddImagesToVersion",
			Handler:    _CruxImage_AddImagesToVersion_Handler,
		},
		{
			MethodName: "OrderImages",
			Handler:    _CruxImage_OrderImages_Handler,
		},
		{
			MethodName: "PatchImage",
			Handler:    _CruxImage_PatchImage_Handler,
		},
		{
			MethodName: "DeleteImage",
			Handler:    _CruxImage_DeleteImage_Handler,
		},
		{
			MethodName: "GetImageDetails",
			Handler:    _CruxImage_GetImageDetails_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxDeploymentClient is the client API for CruxDeployment service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxDeploymentClient interface {
	GetDeploymentsByVersionId(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeploymentListByVersionResponse, error)
	CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	UpdateDeployment(ctx context.Context, in *UpdateDeploymentRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error)
	PatchDeployment(ctx context.Context, in *PatchDeploymentRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error)
	DeleteDeployment(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetDeploymentDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeploymentDetailsResponse, error)
	GetDeploymentEvents(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeploymentEventListResponse, error)
	GetDeploymentList(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*DeploymentListResponse, error)
	GetDeploymentSecrets(ctx context.Context, in *DeploymentListSecretsRequest, opts ...grpc.CallOption) (*common.ListSecretsResponse, error)
	CopyDeploymentSafe(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	CopyDeploymentUnsafe(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	StartDeployment(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	SubscribeToDeploymentEvents(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (CruxDeployment_SubscribeToDeploymentEventsClient, error)
	SubscribeToDeploymentEditEvents(ctx context.Context, in *ServiceIdRequest, opts ...grpc.CallOption) (CruxDeployment_SubscribeToDeploymentEditEventsClient, error)
}

type cruxDeploymentClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxDeploymentClient(cc grpc.ClientConnInterface) CruxDeploymentClient {
	return &cruxDeploymentClient{cc}
}

func (c *cruxDeploymentClient) GetDeploymentsByVersionId(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeploymentListByVersionResponse, error) {
	out := new(DeploymentListByVersionResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/GetDeploymentsByVersionId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/CreateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) UpdateDeployment(ctx context.Context, in *UpdateDeploymentRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error) {
	out := new(UpdateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/UpdateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) PatchDeployment(ctx context.Context, in *PatchDeploymentRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error) {
	out := new(UpdateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/PatchDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) DeleteDeployment(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/DeleteDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) GetDeploymentDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeploymentDetailsResponse, error) {
	out := new(DeploymentDetailsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/GetDeploymentDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) GetDeploymentEvents(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*DeploymentEventListResponse, error) {
	out := new(DeploymentEventListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/GetDeploymentEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) GetDeploymentList(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*DeploymentListResponse, error) {
	out := new(DeploymentListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/GetDeploymentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) GetDeploymentSecrets(ctx context.Context, in *DeploymentListSecretsRequest, opts ...grpc.CallOption) (*common.ListSecretsResponse, error) {
	out := new(common.ListSecretsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/GetDeploymentSecrets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) CopyDeploymentSafe(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/CopyDeploymentSafe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) CopyDeploymentUnsafe(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/CopyDeploymentUnsafe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) StartDeployment(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxDeployment/StartDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxDeploymentClient) SubscribeToDeploymentEvents(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (CruxDeployment_SubscribeToDeploymentEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &CruxDeployment_ServiceDesc.Streams[0], "/crux.CruxDeployment/SubscribeToDeploymentEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &cruxDeploymentSubscribeToDeploymentEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CruxDeployment_SubscribeToDeploymentEventsClient interface {
	Recv() (*DeploymentProgressMessage, error)
	grpc.ClientStream
}

type cruxDeploymentSubscribeToDeploymentEventsClient struct {
	grpc.ClientStream
}

func (x *cruxDeploymentSubscribeToDeploymentEventsClient) Recv() (*DeploymentProgressMessage, error) {
	m := new(DeploymentProgressMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cruxDeploymentClient) SubscribeToDeploymentEditEvents(ctx context.Context, in *ServiceIdRequest, opts ...grpc.CallOption) (CruxDeployment_SubscribeToDeploymentEditEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &CruxDeployment_ServiceDesc.Streams[1], "/crux.CruxDeployment/SubscribeToDeploymentEditEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &cruxDeploymentSubscribeToDeploymentEditEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CruxDeployment_SubscribeToDeploymentEditEventsClient interface {
	Recv() (*DeploymentEditEventMessage, error)
	grpc.ClientStream
}

type cruxDeploymentSubscribeToDeploymentEditEventsClient struct {
	grpc.ClientStream
}

func (x *cruxDeploymentSubscribeToDeploymentEditEventsClient) Recv() (*DeploymentEditEventMessage, error) {
	m := new(DeploymentEditEventMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CruxDeploymentServer is the server API for CruxDeployment service.
// All implementations must embed UnimplementedCruxDeploymentServer
// for forward compatibility
type CruxDeploymentServer interface {
	GetDeploymentsByVersionId(context.Context, *IdRequest) (*DeploymentListByVersionResponse, error)
	CreateDeployment(context.Context, *CreateDeploymentRequest) (*CreateEntityResponse, error)
	UpdateDeployment(context.Context, *UpdateDeploymentRequest) (*UpdateEntityResponse, error)
	PatchDeployment(context.Context, *PatchDeploymentRequest) (*UpdateEntityResponse, error)
	DeleteDeployment(context.Context, *IdRequest) (*common.Empty, error)
	GetDeploymentDetails(context.Context, *IdRequest) (*DeploymentDetailsResponse, error)
	GetDeploymentEvents(context.Context, *IdRequest) (*DeploymentEventListResponse, error)
	GetDeploymentList(context.Context, *AccessRequest) (*DeploymentListResponse, error)
	GetDeploymentSecrets(context.Context, *DeploymentListSecretsRequest) (*common.ListSecretsResponse, error)
	CopyDeploymentSafe(context.Context, *IdRequest) (*CreateEntityResponse, error)
	CopyDeploymentUnsafe(context.Context, *IdRequest) (*CreateEntityResponse, error)
	StartDeployment(context.Context, *IdRequest) (*common.Empty, error)
	SubscribeToDeploymentEvents(*IdRequest, CruxDeployment_SubscribeToDeploymentEventsServer) error
	SubscribeToDeploymentEditEvents(*ServiceIdRequest, CruxDeployment_SubscribeToDeploymentEditEventsServer) error
	mustEmbedUnimplementedCruxDeploymentServer()
}

// UnimplementedCruxDeploymentServer must be embedded to have forward compatible implementations.
type UnimplementedCruxDeploymentServer struct {
}

func (UnimplementedCruxDeploymentServer) GetDeploymentsByVersionId(context.Context, *IdRequest) (*DeploymentListByVersionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentsByVersionId not implemented")
}
func (UnimplementedCruxDeploymentServer) CreateDeployment(context.Context, *CreateDeploymentRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeployment not implemented")
}
func (UnimplementedCruxDeploymentServer) UpdateDeployment(context.Context, *UpdateDeploymentRequest) (*UpdateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeployment not implemented")
}
func (UnimplementedCruxDeploymentServer) PatchDeployment(context.Context, *PatchDeploymentRequest) (*UpdateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchDeployment not implemented")
}
func (UnimplementedCruxDeploymentServer) DeleteDeployment(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDeployment not implemented")
}
func (UnimplementedCruxDeploymentServer) GetDeploymentDetails(context.Context, *IdRequest) (*DeploymentDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentDetails not implemented")
}
func (UnimplementedCruxDeploymentServer) GetDeploymentEvents(context.Context, *IdRequest) (*DeploymentEventListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentEvents not implemented")
}
func (UnimplementedCruxDeploymentServer) GetDeploymentList(context.Context, *AccessRequest) (*DeploymentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentList not implemented")
}
func (UnimplementedCruxDeploymentServer) GetDeploymentSecrets(context.Context, *DeploymentListSecretsRequest) (*common.ListSecretsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentSecrets not implemented")
}
func (UnimplementedCruxDeploymentServer) CopyDeploymentSafe(context.Context, *IdRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyDeploymentSafe not implemented")
}
func (UnimplementedCruxDeploymentServer) CopyDeploymentUnsafe(context.Context, *IdRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyDeploymentUnsafe not implemented")
}
func (UnimplementedCruxDeploymentServer) StartDeployment(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartDeployment not implemented")
}
func (UnimplementedCruxDeploymentServer) SubscribeToDeploymentEvents(*IdRequest, CruxDeployment_SubscribeToDeploymentEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToDeploymentEvents not implemented")
}
func (UnimplementedCruxDeploymentServer) SubscribeToDeploymentEditEvents(*ServiceIdRequest, CruxDeployment_SubscribeToDeploymentEditEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToDeploymentEditEvents not implemented")
}
func (UnimplementedCruxDeploymentServer) mustEmbedUnimplementedCruxDeploymentServer() {}

// UnsafeCruxDeploymentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxDeploymentServer will
// result in compilation errors.
type UnsafeCruxDeploymentServer interface {
	mustEmbedUnimplementedCruxDeploymentServer()
}

func RegisterCruxDeploymentServer(s grpc.ServiceRegistrar, srv CruxDeploymentServer) {
	s.RegisterService(&CruxDeployment_ServiceDesc, srv)
}

func _CruxDeployment_GetDeploymentsByVersionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).GetDeploymentsByVersionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/GetDeploymentsByVersionId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).GetDeploymentsByVersionId(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_CreateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).CreateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/CreateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).CreateDeployment(ctx, req.(*CreateDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_UpdateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).UpdateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/UpdateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).UpdateDeployment(ctx, req.(*UpdateDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_PatchDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).PatchDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/PatchDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).PatchDeployment(ctx, req.(*PatchDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_DeleteDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).DeleteDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/DeleteDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).DeleteDeployment(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_GetDeploymentDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).GetDeploymentDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/GetDeploymentDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).GetDeploymentDetails(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_GetDeploymentEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).GetDeploymentEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/GetDeploymentEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).GetDeploymentEvents(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_GetDeploymentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).GetDeploymentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/GetDeploymentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).GetDeploymentList(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_GetDeploymentSecrets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeploymentListSecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).GetDeploymentSecrets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/GetDeploymentSecrets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).GetDeploymentSecrets(ctx, req.(*DeploymentListSecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_CopyDeploymentSafe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).CopyDeploymentSafe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/CopyDeploymentSafe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).CopyDeploymentSafe(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_CopyDeploymentUnsafe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).CopyDeploymentUnsafe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/CopyDeploymentUnsafe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).CopyDeploymentUnsafe(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_StartDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxDeploymentServer).StartDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxDeployment/StartDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxDeploymentServer).StartDeployment(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxDeployment_SubscribeToDeploymentEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CruxDeploymentServer).SubscribeToDeploymentEvents(m, &cruxDeploymentSubscribeToDeploymentEventsServer{stream})
}

type CruxDeployment_SubscribeToDeploymentEventsServer interface {
	Send(*DeploymentProgressMessage) error
	grpc.ServerStream
}

type cruxDeploymentSubscribeToDeploymentEventsServer struct {
	grpc.ServerStream
}

func (x *cruxDeploymentSubscribeToDeploymentEventsServer) Send(m *DeploymentProgressMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _CruxDeployment_SubscribeToDeploymentEditEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ServiceIdRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CruxDeploymentServer).SubscribeToDeploymentEditEvents(m, &cruxDeploymentSubscribeToDeploymentEditEventsServer{stream})
}

type CruxDeployment_SubscribeToDeploymentEditEventsServer interface {
	Send(*DeploymentEditEventMessage) error
	grpc.ServerStream
}

type cruxDeploymentSubscribeToDeploymentEditEventsServer struct {
	grpc.ServerStream
}

func (x *cruxDeploymentSubscribeToDeploymentEditEventsServer) Send(m *DeploymentEditEventMessage) error {
	return x.ServerStream.SendMsg(m)
}

// CruxDeployment_ServiceDesc is the grpc.ServiceDesc for CruxDeployment service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxDeployment_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxDeployment",
	HandlerType: (*CruxDeploymentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDeploymentsByVersionId",
			Handler:    _CruxDeployment_GetDeploymentsByVersionId_Handler,
		},
		{
			MethodName: "CreateDeployment",
			Handler:    _CruxDeployment_CreateDeployment_Handler,
		},
		{
			MethodName: "UpdateDeployment",
			Handler:    _CruxDeployment_UpdateDeployment_Handler,
		},
		{
			MethodName: "PatchDeployment",
			Handler:    _CruxDeployment_PatchDeployment_Handler,
		},
		{
			MethodName: "DeleteDeployment",
			Handler:    _CruxDeployment_DeleteDeployment_Handler,
		},
		{
			MethodName: "GetDeploymentDetails",
			Handler:    _CruxDeployment_GetDeploymentDetails_Handler,
		},
		{
			MethodName: "GetDeploymentEvents",
			Handler:    _CruxDeployment_GetDeploymentEvents_Handler,
		},
		{
			MethodName: "GetDeploymentList",
			Handler:    _CruxDeployment_GetDeploymentList_Handler,
		},
		{
			MethodName: "GetDeploymentSecrets",
			Handler:    _CruxDeployment_GetDeploymentSecrets_Handler,
		},
		{
			MethodName: "CopyDeploymentSafe",
			Handler:    _CruxDeployment_CopyDeploymentSafe_Handler,
		},
		{
			MethodName: "CopyDeploymentUnsafe",
			Handler:    _CruxDeployment_CopyDeploymentUnsafe_Handler,
		},
		{
			MethodName: "StartDeployment",
			Handler:    _CruxDeployment_StartDeployment_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToDeploymentEvents",
			Handler:       _CruxDeployment_SubscribeToDeploymentEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToDeploymentEditEvents",
			Handler:       _CruxDeployment_SubscribeToDeploymentEditEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxTeamClient is the client API for CruxTeam service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxTeamClient interface {
	CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	GetActiveTeamByUser(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*ActiveTeamDetailsResponse, error)
	UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*common.Empty, error)
	DeleteTeam(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	UpdateUserRole(ctx context.Context, in *UpdateUserRoleInTeamRequest, opts ...grpc.CallOption) (*common.Empty, error)
	InviteUserToTeam(ctx context.Context, in *InviteUserRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	ReinviteUserToTeam(ctx context.Context, in *ReinviteUserRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
	DeleteUserFromTeam(ctx context.Context, in *DeleteUserFromTeamRequest, opts ...grpc.CallOption) (*common.Empty, error)
	AcceptTeamInvitation(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	DeclineTeamInvitation(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	SelectTeam(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetUserMeta(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*UserMetaResponse, error)
	GetAllTeams(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*AllTeamsResponse, error)
	GetTeamById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*TeamDetailsResponse, error)
}

type cruxTeamClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxTeamClient(cc grpc.ClientConnInterface) CruxTeamClient {
	return &cruxTeamClient{cc}
}

func (c *cruxTeamClient) CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/CreateTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) GetActiveTeamByUser(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*ActiveTeamDetailsResponse, error) {
	out := new(ActiveTeamDetailsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/GetActiveTeamByUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/UpdateTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) DeleteTeam(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/DeleteTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) UpdateUserRole(ctx context.Context, in *UpdateUserRoleInTeamRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/UpdateUserRole", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) InviteUserToTeam(ctx context.Context, in *InviteUserRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/InviteUserToTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) ReinviteUserToTeam(ctx context.Context, in *ReinviteUserRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/ReinviteUserToTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) DeleteUserFromTeam(ctx context.Context, in *DeleteUserFromTeamRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/DeleteUserFromTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) AcceptTeamInvitation(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/AcceptTeamInvitation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) DeclineTeamInvitation(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/DeclineTeamInvitation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) SelectTeam(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/SelectTeam", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) GetUserMeta(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*UserMetaResponse, error) {
	out := new(UserMetaResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/GetUserMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) GetAllTeams(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*AllTeamsResponse, error) {
	out := new(AllTeamsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/GetAllTeams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTeamClient) GetTeamById(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*TeamDetailsResponse, error) {
	out := new(TeamDetailsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTeam/GetTeamById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxTeamServer is the server API for CruxTeam service.
// All implementations must embed UnimplementedCruxTeamServer
// for forward compatibility
type CruxTeamServer interface {
	CreateTeam(context.Context, *CreateTeamRequest) (*CreateEntityResponse, error)
	GetActiveTeamByUser(context.Context, *AccessRequest) (*ActiveTeamDetailsResponse, error)
	UpdateTeam(context.Context, *UpdateTeamRequest) (*common.Empty, error)
	DeleteTeam(context.Context, *IdRequest) (*common.Empty, error)
	UpdateUserRole(context.Context, *UpdateUserRoleInTeamRequest) (*common.Empty, error)
	InviteUserToTeam(context.Context, *InviteUserRequest) (*CreateEntityResponse, error)
	ReinviteUserToTeam(context.Context, *ReinviteUserRequest) (*CreateEntityResponse, error)
	DeleteUserFromTeam(context.Context, *DeleteUserFromTeamRequest) (*common.Empty, error)
	AcceptTeamInvitation(context.Context, *IdRequest) (*common.Empty, error)
	DeclineTeamInvitation(context.Context, *IdRequest) (*common.Empty, error)
	SelectTeam(context.Context, *IdRequest) (*common.Empty, error)
	GetUserMeta(context.Context, *AccessRequest) (*UserMetaResponse, error)
	GetAllTeams(context.Context, *AccessRequest) (*AllTeamsResponse, error)
	GetTeamById(context.Context, *IdRequest) (*TeamDetailsResponse, error)
	mustEmbedUnimplementedCruxTeamServer()
}

// UnimplementedCruxTeamServer must be embedded to have forward compatible implementations.
type UnimplementedCruxTeamServer struct {
}

func (UnimplementedCruxTeamServer) CreateTeam(context.Context, *CreateTeamRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTeam not implemented")
}
func (UnimplementedCruxTeamServer) GetActiveTeamByUser(context.Context, *AccessRequest) (*ActiveTeamDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveTeamByUser not implemented")
}
func (UnimplementedCruxTeamServer) UpdateTeam(context.Context, *UpdateTeamRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTeam not implemented")
}
func (UnimplementedCruxTeamServer) DeleteTeam(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTeam not implemented")
}
func (UnimplementedCruxTeamServer) UpdateUserRole(context.Context, *UpdateUserRoleInTeamRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserRole not implemented")
}
func (UnimplementedCruxTeamServer) InviteUserToTeam(context.Context, *InviteUserRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteUserToTeam not implemented")
}
func (UnimplementedCruxTeamServer) ReinviteUserToTeam(context.Context, *ReinviteUserRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReinviteUserToTeam not implemented")
}
func (UnimplementedCruxTeamServer) DeleteUserFromTeam(context.Context, *DeleteUserFromTeamRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserFromTeam not implemented")
}
func (UnimplementedCruxTeamServer) AcceptTeamInvitation(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptTeamInvitation not implemented")
}
func (UnimplementedCruxTeamServer) DeclineTeamInvitation(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeclineTeamInvitation not implemented")
}
func (UnimplementedCruxTeamServer) SelectTeam(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectTeam not implemented")
}
func (UnimplementedCruxTeamServer) GetUserMeta(context.Context, *AccessRequest) (*UserMetaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserMeta not implemented")
}
func (UnimplementedCruxTeamServer) GetAllTeams(context.Context, *AccessRequest) (*AllTeamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTeams not implemented")
}
func (UnimplementedCruxTeamServer) GetTeamById(context.Context, *IdRequest) (*TeamDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeamById not implemented")
}
func (UnimplementedCruxTeamServer) mustEmbedUnimplementedCruxTeamServer() {}

// UnsafeCruxTeamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxTeamServer will
// result in compilation errors.
type UnsafeCruxTeamServer interface {
	mustEmbedUnimplementedCruxTeamServer()
}

func RegisterCruxTeamServer(s grpc.ServiceRegistrar, srv CruxTeamServer) {
	s.RegisterService(&CruxTeam_ServiceDesc, srv)
}

func _CruxTeam_CreateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).CreateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/CreateTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).CreateTeam(ctx, req.(*CreateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_GetActiveTeamByUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).GetActiveTeamByUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/GetActiveTeamByUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).GetActiveTeamByUser(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_UpdateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).UpdateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/UpdateTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).UpdateTeam(ctx, req.(*UpdateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_DeleteTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).DeleteTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/DeleteTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).DeleteTeam(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_UpdateUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRoleInTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).UpdateUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/UpdateUserRole",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).UpdateUserRole(ctx, req.(*UpdateUserRoleInTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_InviteUserToTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InviteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).InviteUserToTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/InviteUserToTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).InviteUserToTeam(ctx, req.(*InviteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_ReinviteUserToTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReinviteUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).ReinviteUserToTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/ReinviteUserToTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).ReinviteUserToTeam(ctx, req.(*ReinviteUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_DeleteUserFromTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserFromTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).DeleteUserFromTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/DeleteUserFromTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).DeleteUserFromTeam(ctx, req.(*DeleteUserFromTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_AcceptTeamInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).AcceptTeamInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/AcceptTeamInvitation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).AcceptTeamInvitation(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_DeclineTeamInvitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).DeclineTeamInvitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/DeclineTeamInvitation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).DeclineTeamInvitation(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_SelectTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).SelectTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/SelectTeam",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).SelectTeam(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_GetUserMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).GetUserMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/GetUserMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).GetUserMeta(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_GetAllTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).GetAllTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/GetAllTeams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).GetAllTeams(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTeam_GetTeamById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTeamServer).GetTeamById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTeam/GetTeamById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTeamServer).GetTeamById(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxTeam_ServiceDesc is the grpc.ServiceDesc for CruxTeam service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxTeam_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxTeam",
	HandlerType: (*CruxTeamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTeam",
			Handler:    _CruxTeam_CreateTeam_Handler,
		},
		{
			MethodName: "GetActiveTeamByUser",
			Handler:    _CruxTeam_GetActiveTeamByUser_Handler,
		},
		{
			MethodName: "UpdateTeam",
			Handler:    _CruxTeam_UpdateTeam_Handler,
		},
		{
			MethodName: "DeleteTeam",
			Handler:    _CruxTeam_DeleteTeam_Handler,
		},
		{
			MethodName: "UpdateUserRole",
			Handler:    _CruxTeam_UpdateUserRole_Handler,
		},
		{
			MethodName: "InviteUserToTeam",
			Handler:    _CruxTeam_InviteUserToTeam_Handler,
		},
		{
			MethodName: "ReinviteUserToTeam",
			Handler:    _CruxTeam_ReinviteUserToTeam_Handler,
		},
		{
			MethodName: "DeleteUserFromTeam",
			Handler:    _CruxTeam_DeleteUserFromTeam_Handler,
		},
		{
			MethodName: "AcceptTeamInvitation",
			Handler:    _CruxTeam_AcceptTeamInvitation_Handler,
		},
		{
			MethodName: "DeclineTeamInvitation",
			Handler:    _CruxTeam_DeclineTeamInvitation_Handler,
		},
		{
			MethodName: "SelectTeam",
			Handler:    _CruxTeam_SelectTeam_Handler,
		},
		{
			MethodName: "GetUserMeta",
			Handler:    _CruxTeam_GetUserMeta_Handler,
		},
		{
			MethodName: "GetAllTeams",
			Handler:    _CruxTeam_GetAllTeams_Handler,
		},
		{
			MethodName: "GetTeamById",
			Handler:    _CruxTeam_GetTeamById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxNotificationClient is the client API for CruxNotification service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxNotificationClient interface {
	CreateNotification(ctx context.Context, in *CreateNotificationRequest, opts ...grpc.CallOption) (*CreateNotificationResponse, error)
	UpdateNotification(ctx context.Context, in *UpdateNotificationRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error)
	DeleteNotification(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
	GetNotificationList(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*NotificationListResponse, error)
	GetNotificationDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*NotificationDetailsResponse, error)
	TestNotification(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type cruxNotificationClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxNotificationClient(cc grpc.ClientConnInterface) CruxNotificationClient {
	return &cruxNotificationClient{cc}
}

func (c *cruxNotificationClient) CreateNotification(ctx context.Context, in *CreateNotificationRequest, opts ...grpc.CallOption) (*CreateNotificationResponse, error) {
	out := new(CreateNotificationResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNotification/CreateNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNotificationClient) UpdateNotification(ctx context.Context, in *UpdateNotificationRequest, opts ...grpc.CallOption) (*UpdateEntityResponse, error) {
	out := new(UpdateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNotification/UpdateNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNotificationClient) DeleteNotification(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxNotification/DeleteNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNotificationClient) GetNotificationList(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*NotificationListResponse, error) {
	out := new(NotificationListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNotification/GetNotificationList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNotificationClient) GetNotificationDetails(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*NotificationDetailsResponse, error) {
	out := new(NotificationDetailsResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxNotification/GetNotificationDetails", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxNotificationClient) TestNotification(ctx context.Context, in *IdRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, "/crux.CruxNotification/TestNotification", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxNotificationServer is the server API for CruxNotification service.
// All implementations must embed UnimplementedCruxNotificationServer
// for forward compatibility
type CruxNotificationServer interface {
	CreateNotification(context.Context, *CreateNotificationRequest) (*CreateNotificationResponse, error)
	UpdateNotification(context.Context, *UpdateNotificationRequest) (*UpdateEntityResponse, error)
	DeleteNotification(context.Context, *IdRequest) (*common.Empty, error)
	GetNotificationList(context.Context, *AccessRequest) (*NotificationListResponse, error)
	GetNotificationDetails(context.Context, *IdRequest) (*NotificationDetailsResponse, error)
	TestNotification(context.Context, *IdRequest) (*common.Empty, error)
	mustEmbedUnimplementedCruxNotificationServer()
}

// UnimplementedCruxNotificationServer must be embedded to have forward compatible implementations.
type UnimplementedCruxNotificationServer struct {
}

func (UnimplementedCruxNotificationServer) CreateNotification(context.Context, *CreateNotificationRequest) (*CreateNotificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNotification not implemented")
}
func (UnimplementedCruxNotificationServer) UpdateNotification(context.Context, *UpdateNotificationRequest) (*UpdateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNotification not implemented")
}
func (UnimplementedCruxNotificationServer) DeleteNotification(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNotification not implemented")
}
func (UnimplementedCruxNotificationServer) GetNotificationList(context.Context, *AccessRequest) (*NotificationListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationList not implemented")
}
func (UnimplementedCruxNotificationServer) GetNotificationDetails(context.Context, *IdRequest) (*NotificationDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNotificationDetails not implemented")
}
func (UnimplementedCruxNotificationServer) TestNotification(context.Context, *IdRequest) (*common.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestNotification not implemented")
}
func (UnimplementedCruxNotificationServer) mustEmbedUnimplementedCruxNotificationServer() {}

// UnsafeCruxNotificationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxNotificationServer will
// result in compilation errors.
type UnsafeCruxNotificationServer interface {
	mustEmbedUnimplementedCruxNotificationServer()
}

func RegisterCruxNotificationServer(s grpc.ServiceRegistrar, srv CruxNotificationServer) {
	s.RegisterService(&CruxNotification_ServiceDesc, srv)
}

func _CruxNotification_CreateNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNotificationServer).CreateNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNotification/CreateNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNotificationServer).CreateNotification(ctx, req.(*CreateNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNotification_UpdateNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNotificationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNotificationServer).UpdateNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNotification/UpdateNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNotificationServer).UpdateNotification(ctx, req.(*UpdateNotificationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNotification_DeleteNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNotificationServer).DeleteNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNotification/DeleteNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNotificationServer).DeleteNotification(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNotification_GetNotificationList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNotificationServer).GetNotificationList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNotification/GetNotificationList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNotificationServer).GetNotificationList(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNotification_GetNotificationDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNotificationServer).GetNotificationDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNotification/GetNotificationDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNotificationServer).GetNotificationDetails(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxNotification_TestNotification_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxNotificationServer).TestNotification(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxNotification/TestNotification",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxNotificationServer).TestNotification(ctx, req.(*IdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxNotification_ServiceDesc is the grpc.ServiceDesc for CruxNotification service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxNotification_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxNotification",
	HandlerType: (*CruxNotificationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNotification",
			Handler:    _CruxNotification_CreateNotification_Handler,
		},
		{
			MethodName: "UpdateNotification",
			Handler:    _CruxNotification_UpdateNotification_Handler,
		},
		{
			MethodName: "DeleteNotification",
			Handler:    _CruxNotification_DeleteNotification_Handler,
		},
		{
			MethodName: "GetNotificationList",
			Handler:    _CruxNotification_GetNotificationList_Handler,
		},
		{
			MethodName: "GetNotificationDetails",
			Handler:    _CruxNotification_GetNotificationDetails_Handler,
		},
		{
			MethodName: "TestNotification",
			Handler:    _CruxNotification_TestNotification_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxAuditClient is the client API for CruxAudit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxAuditClient interface {
	GetAuditLog(ctx context.Context, in *AuditLogListRequest, opts ...grpc.CallOption) (*AuditLogListResponse, error)
	GetAuditLogListCount(ctx context.Context, in *AuditLogListRequest, opts ...grpc.CallOption) (*AuditLogListCountResponse, error)
}

type cruxAuditClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxAuditClient(cc grpc.ClientConnInterface) CruxAuditClient {
	return &cruxAuditClient{cc}
}

func (c *cruxAuditClient) GetAuditLog(ctx context.Context, in *AuditLogListRequest, opts ...grpc.CallOption) (*AuditLogListResponse, error) {
	out := new(AuditLogListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxAudit/GetAuditLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxAuditClient) GetAuditLogListCount(ctx context.Context, in *AuditLogListRequest, opts ...grpc.CallOption) (*AuditLogListCountResponse, error) {
	out := new(AuditLogListCountResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxAudit/GetAuditLogListCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxAuditServer is the server API for CruxAudit service.
// All implementations must embed UnimplementedCruxAuditServer
// for forward compatibility
type CruxAuditServer interface {
	GetAuditLog(context.Context, *AuditLogListRequest) (*AuditLogListResponse, error)
	GetAuditLogListCount(context.Context, *AuditLogListRequest) (*AuditLogListCountResponse, error)
	mustEmbedUnimplementedCruxAuditServer()
}

// UnimplementedCruxAuditServer must be embedded to have forward compatible implementations.
type UnimplementedCruxAuditServer struct {
}

func (UnimplementedCruxAuditServer) GetAuditLog(context.Context, *AuditLogListRequest) (*AuditLogListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuditLog not implemented")
}
func (UnimplementedCruxAuditServer) GetAuditLogListCount(context.Context, *AuditLogListRequest) (*AuditLogListCountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuditLogListCount not implemented")
}
func (UnimplementedCruxAuditServer) mustEmbedUnimplementedCruxAuditServer() {}

// UnsafeCruxAuditServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxAuditServer will
// result in compilation errors.
type UnsafeCruxAuditServer interface {
	mustEmbedUnimplementedCruxAuditServer()
}

func RegisterCruxAuditServer(s grpc.ServiceRegistrar, srv CruxAuditServer) {
	s.RegisterService(&CruxAudit_ServiceDesc, srv)
}

func _CruxAudit_GetAuditLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuditLogListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxAuditServer).GetAuditLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxAudit/GetAuditLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxAuditServer).GetAuditLog(ctx, req.(*AuditLogListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxAudit_GetAuditLogListCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuditLogListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxAuditServer).GetAuditLogListCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxAudit/GetAuditLogListCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxAuditServer).GetAuditLogListCount(ctx, req.(*AuditLogListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxAudit_ServiceDesc is the grpc.ServiceDesc for CruxAudit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxAudit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxAudit",
	HandlerType: (*CruxAuditServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuditLog",
			Handler:    _CruxAudit_GetAuditLog_Handler,
		},
		{
			MethodName: "GetAuditLogListCount",
			Handler:    _CruxAudit_GetAuditLogListCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxHealthClient is the client API for CruxHealth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxHealthClient interface {
	GetHealth(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*HealthResponse, error)
}

type cruxHealthClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxHealthClient(cc grpc.ClientConnInterface) CruxHealthClient {
	return &cruxHealthClient{cc}
}

func (c *cruxHealthClient) GetHealth(ctx context.Context, in *common.Empty, opts ...grpc.CallOption) (*HealthResponse, error) {
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxHealth/getHealth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxHealthServer is the server API for CruxHealth service.
// All implementations must embed UnimplementedCruxHealthServer
// for forward compatibility
type CruxHealthServer interface {
	GetHealth(context.Context, *common.Empty) (*HealthResponse, error)
	mustEmbedUnimplementedCruxHealthServer()
}

// UnimplementedCruxHealthServer must be embedded to have forward compatible implementations.
type UnimplementedCruxHealthServer struct {
}

func (UnimplementedCruxHealthServer) GetHealth(context.Context, *common.Empty) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedCruxHealthServer) mustEmbedUnimplementedCruxHealthServer() {}

// UnsafeCruxHealthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxHealthServer will
// result in compilation errors.
type UnsafeCruxHealthServer interface {
	mustEmbedUnimplementedCruxHealthServer()
}

func RegisterCruxHealthServer(s grpc.ServiceRegistrar, srv CruxHealthServer) {
	s.RegisterService(&CruxHealth_ServiceDesc, srv)
}

func _CruxHealth_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxHealthServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxHealth/getHealth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxHealthServer).GetHealth(ctx, req.(*common.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxHealth_ServiceDesc is the grpc.ServiceDesc for CruxHealth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxHealth_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxHealth",
	HandlerType: (*CruxHealthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "getHealth",
			Handler:    _CruxHealth_GetHealth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}

// CruxTemplateClient is the client API for CruxTemplate service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CruxTemplateClient interface {
	GetTemplates(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*TemplateListResponse, error)
	CreateProductFromTemplate(ctx context.Context, in *CreateProductFromTemplateRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error)
}

type cruxTemplateClient struct {
	cc grpc.ClientConnInterface
}

func NewCruxTemplateClient(cc grpc.ClientConnInterface) CruxTemplateClient {
	return &cruxTemplateClient{cc}
}

func (c *cruxTemplateClient) GetTemplates(ctx context.Context, in *AccessRequest, opts ...grpc.CallOption) (*TemplateListResponse, error) {
	out := new(TemplateListResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTemplate/GetTemplates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cruxTemplateClient) CreateProductFromTemplate(ctx context.Context, in *CreateProductFromTemplateRequest, opts ...grpc.CallOption) (*CreateEntityResponse, error) {
	out := new(CreateEntityResponse)
	err := c.cc.Invoke(ctx, "/crux.CruxTemplate/CreateProductFromTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CruxTemplateServer is the server API for CruxTemplate service.
// All implementations must embed UnimplementedCruxTemplateServer
// for forward compatibility
type CruxTemplateServer interface {
	GetTemplates(context.Context, *AccessRequest) (*TemplateListResponse, error)
	CreateProductFromTemplate(context.Context, *CreateProductFromTemplateRequest) (*CreateEntityResponse, error)
	mustEmbedUnimplementedCruxTemplateServer()
}

// UnimplementedCruxTemplateServer must be embedded to have forward compatible implementations.
type UnimplementedCruxTemplateServer struct {
}

func (UnimplementedCruxTemplateServer) GetTemplates(context.Context, *AccessRequest) (*TemplateListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTemplates not implemented")
}
func (UnimplementedCruxTemplateServer) CreateProductFromTemplate(context.Context, *CreateProductFromTemplateRequest) (*CreateEntityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProductFromTemplate not implemented")
}
func (UnimplementedCruxTemplateServer) mustEmbedUnimplementedCruxTemplateServer() {}

// UnsafeCruxTemplateServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CruxTemplateServer will
// result in compilation errors.
type UnsafeCruxTemplateServer interface {
	mustEmbedUnimplementedCruxTemplateServer()
}

func RegisterCruxTemplateServer(s grpc.ServiceRegistrar, srv CruxTemplateServer) {
	s.RegisterService(&CruxTemplate_ServiceDesc, srv)
}

func _CruxTemplate_GetTemplates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTemplateServer).GetTemplates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTemplate/GetTemplates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTemplateServer).GetTemplates(ctx, req.(*AccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CruxTemplate_CreateProductFromTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductFromTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CruxTemplateServer).CreateProductFromTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crux.CruxTemplate/CreateProductFromTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CruxTemplateServer).CreateProductFromTemplate(ctx, req.(*CreateProductFromTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CruxTemplate_ServiceDesc is the grpc.ServiceDesc for CruxTemplate service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CruxTemplate_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crux.CruxTemplate",
	HandlerType: (*CruxTemplateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTemplates",
			Handler:    _CruxTemplate_GetTemplates_Handler,
		},
		{
			MethodName: "CreateProductFromTemplate",
			Handler:    _CruxTemplate_CreateProductFromTemplate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/proto/crux.proto",
}
